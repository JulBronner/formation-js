<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8">

	<title>JS, ES6, lodash, ...</title>

	<meta name="description" content="Une formation sur le JS">
	<meta name="author" content="Pierre Besson">


	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	var link = document.createElement( 'link' );
	link.rel = 'stylesheet';
	link.type = 'text/css';
	link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
	document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<link href='https://fonts.googleapis.com/css?family=Merriweather:700|Source+Sans+Pro:300,600,300italic,600italic|Source+Code+Pro:400,600' rel='stylesheet' type='text/css'>


</head>

<body>


	<div class="reveal">
		<div class="slides">
			<section data-background='#ffe599'><h1>Javascript</h1></section>
			<section data-background='https://cdn.nextinpact.com/images/bd/news/124984.png'>
				<style scoped>
				      h1#jquery { color: red; font-weight: bold; background-color: yellow;}
				</style>
				<h1 id='jquery'>JS !== jQuery</h1>
			</section>
			<section>
				<section data-background='https://media.giphy.com/media/vKZKZ0I9nCAGA/giphy.gif'><h1>Les bases</h1></section>
				<section data-markdown>
## Les variables

- `const`  Variable constante qui ne peut plus être modifiée
- `var`  portée globale ou locale a une fonction
- `let` portée du block courant `{}`

> A retenir on utlise `const` au maximum et `let` dans les autres cas

				</section>
				<section>
					<h2>Les strings</h2>
					<pre>
						<code class='javascript'>
'déjà' < 'demain'              // => false
'déjà'.localeCompare('demain') // => -1 ('déjà' avant 'demain')

'déjà !'.toLocaleUpperCase()      // => 'DÉJÀ !'
'ÇA POUTRE'.toLocaleLowerCase()   // => 'ça poutre'

'one,two,three'.split(',')        // => ['one', 'two', 'three']
'one,,two,three'.split(/\W+/)     // => ['one', 'two']

'hello'.substring(1)      // => 'ello'
'hello'.slice(1, -2)      // => 'el' -> [1;length-2[
						</code>
					</pre>
				</section>
				<section>
					<h2>Les dates</h2>
					<pre>
						<code class='javascript'>
new Date                   //  maintenant !
new Date(y,m,d[,h,m,s,ms]) // Valeur découpée. (un peu lourd...)

date.getFullYear()  // JAMAIS
date.getMonth()     // NAZE Java-like qui démarre à… zéro (janvier). #ugly
date.getDay()       // PERDUUUU ! C'est le DOW (Day Of Week), 0 = dim., 6 = s
date.getDate()      // Le jour du mois.  Super logique.
date.getHours()
date.getMinutes()
date.getSeconds()
date.getMilliseconds() // "Milliseconds", un seul mot : une seule initiale.

// Heure locale du navigateur/système.  On a les mêmes en getUTCXxx()…
						</code>
					</pre>
				</section>
				<section>
					<h2>Les dates</h2>
					<pre>
						<code class='javascript'>
// "J'ai bien lu la doc"
date.getTime()  // => ex. 1290852603042

// "#superSmart"
+date

// Et sinon…
new Date(1301733937452)

// Mais aussi (car souci pour partir de composantes UTC) :
Date.UTC(y, m, d, h, mn, s, ms) // => numérique

						</code>
					</pre>
				</section>
				<section>
					<blockquote>
						A retenir : Momentjs (on voit ça plus tard...)
					</blockquote>
				</section>

				<section>
					<h2>Les objets</h2>
					<pre>
						<code class='javascript'>
let obj = { first: 'David', last: 'Lopez', age: 77 };
obj.first  // => 'David'
obj['age'] // => 42

obj.first = 'pierr';
obj['first'] // => 'pierr'

obj[77] = 'roberto';
obj[77]   // => 'roberto'
obj['77'] // => 'roberto'
obj.77    // => SyntaxError
						</code>
					</pre>
				</section>
				<section>
					<h2>Les objets avec ES6</h2>
					<pre>
						<code class='javascript'>
let defaults = { first: 'John', last: 'Doe', age: 42 };
let trainer  = { last: 'Smith', age: 35 };
trainer      = { ...defaults, ...trainer, age: 36 }
// => { first: 'John', last: 'Smith', age: 36 }
trainers['a'+ 12] = 'Gino';
trainers.a12;
// Gino
						</code>
					<pre>
				</section>
				<section>
					<h2>Les tableaux</h2>
					<pre>
						<code class='javascript'>
let names = ['John', 'David', 'Rodrigo'];

names.length
// => 3. R/W : astuce pour réutiliser un tableau!

names[0]
// => 'John'

names[12] = 'Pierre';
names.length
// => 13

names[9]
// => undefined (comme 10 et 11): c'est appellé "sparse array"
						</code>
					</pre>
				</section>
				<section>
					<pre>
						<h2>Les tableaux</h2>
						<code class='javascript'>
let data = [1, 2, 3];

// arr1.concat(arg…) -> arr2 [déroule sur 1 niveau, ni "shallow" ni "deep"]
data.concat(4, 5, 6)     // => [1, 2, 3, 4, 5, 6]
data.concat([4, 5, 6])   // => [1, 2, 3, 4, 5, 6]
data.concat(4, [5, 6])   // => [1, 2, 3, 4, 5, 6]
data.concat([4, [5, 6]]) // => [1, 2, 3, 4, [5, 6]] -- 2 niveaux !
data                     // => [1, 2, 3] -- intact !

// arr.join([sep = ',']) -> String
data.join()   // => '1,2,3'
data.join('') // => '123' -- Fréquent en construisant du HTML

// arr1.slice(signedBegin[, signedEnd = length]) -> arr2 -- négatif ok partout !
data.slice(1)      // => [2, 3]
data.slice(1, 1)   // => []
data.slice(1, 2)   // => [2]
data.slice(1, -1)  // => [2]
data.slice(-2)     // => [2, 3]
data.slice(-2, 2)  // => [2]
data.slice(-2, -1) // => [2]
						</code>
					</pre>
				</section>
				<section>
					<pre>
						<h2>Les tableaux en ES6</h2>
						<code class='javascript'>

let arr1 = ['one', 'two'], arr2 = ['three', 'four'];
arr1.push(...arr2) // => 4
arr1                // => ['one', 'two', 'three', 'four']
// for…in itère sur LES PROPRIÉTÉS ÉNUMÉRABLES de N’IMPORTE QUEL OBJET
var arr = ['hello', 'world', , 'cool'];
for (var k in arr){ console.log(k)}; // => 0, 1, 3


						</code>
					</pre>
				</section>
				<section>
					<pre>
						<h2>Haloween pour les tableaux ...</h2>
						<code class='javascript'>
// Toi aussi, déguise-toi en tableau !

var fakeArray = { 0: '!', 1: 'ça torche', 2: 'JavaScript', length: 3 };

fakeArray.join = [].join; fakeArray.reverse = [].reverse;
fakeArray.reverse().join(' ');
// => 'JavaScript ça torche !'

// Ou alors :
fakeArray.__proto__ = Array.prototype;
fakeArray.reverse().join(' ');
// => 'JavaScript ça torche !'

// Méthodes « génériques » utilisables: hn
// concat, join, pop, push, reverse, shift,
// slice, sort, splice, toString, unshift.
						</code>
					</pre>
				</section>
				<section>
					<h2>Les boucles</h2>
					<pre>
						<code class='javascript'>
const ARRAY = [1,2,3,4];
for(let i = 0, _l=ARRAY.length; i < _l; i++ ){console.log(ARRAY[i])}
ARRAY.forEach(function(element, idx){console.log(elt, i)});
ARRAY.map(function(element, idx){console.log(elt, i)});
// transforme le tableau
						</code>
					</pre>
				</section>

				<section>
					<h2>Les fonctions</h2>
					<pre>
						<code class='javascript'>
function maFonction() {
	return 'test';
}
maFonction() // test;
const a = () => 'test';
a(); //test
						</code>
					</pre>
				</section>

				<section>
					<h2>JS c'est logique ...</h2>
					<pre>
						<code>
== ou === ?!

42 == '42'        // => true  -- Argh, ça sent le PHP, là…
null == undefined // => true  -- hmmm…
null == 0         // => false -- heureusement !
0 == undefined    // => false -- heureusement !
0 == false        // => true  -- Façon C…
1 == true         // => true  -- Façon C…
42 == true        // => false -- Watcha ?! (x == ToNumber(y), ES3 §11.9.3)
'0' == false      // => true  -- Woah !
'' == false       // => true  -- Yowza ! 8-O  On y reviendra…
NaN == NaN        // => false -- Bin oué, c’est le principe…
						</code>
					</pre>
				</section>
				<section>
					<h2>En fait si ...</h2>
					<pre>
						<code>
// avec ===, fini de jouer : vérif valeur ET TYPE !

42 === '42'        // => false
null === undefined // => false
null === 0         // => false
0 === undefined    // => false
0 === false        // => false
'0' === false      // => false
NaN === NaN        // => false -- rien à faire !
						</code>
					</pre>
					<blockquote>
						On utilise toujours le <b>===</b>
					</blockquote>
				</section>
				<section>
					<h2>in et delete</h2>
					<pre>
						<code class='javascript'>

let person = { name: 'Joe', langs: ['fr', 'en'] };

'name' in person        // => true
person.age = 35;
'age' in person         // => true
person.age = null;
'age' in person         // => true
delete person.age
'age' in person         // => false
person.age              // => undefined

0 in person.langs       // => true
'0' in person.langs     // => true
person.langs[3] = 'de';
2 in person.langs       // => false
3 in person.langs       // => true
delete person.langs[3]
person.langs            // => ['fr', 'en', undefined, undefined]
						</code>
					</pre>
				</section>
				<section>
					<h2>Falsy / Truthy</h2>
				</section>

			</section>
			<section data-state="theme-color-blue-yellow">
				<section data-background='https://media.giphy.com/media/RHUGfUYnjNuMw/giphy.gif'>
					<h1>Prototypes / Constructor</h1>
				</section>
				<section>
					<h2>Classes ?</h2>
					<ul>
						<li>Avant ES6 pas de classe</li>
						<li>JS est un langage prototypale</li>
						<li>En JS tout est un objet</li>
						<li>Une propriété est identifié par un doubler nom / valeur</li>
						<li>Une propriété peut être une fonction</li>
					</ul>
				</section>
				<section>
					<h2>Constructeur</h2>
					<ul>
					    <li>Fonctions servant à initialiser un nouvel objet. Le nom du constructeur est un peu comme « le nom de la classe »…</li>
					    <li>Toute fonction peut servir de constructeur : il suffit de l’appeler avec l’opérateur new.</li>
					    <li>Elle dispose alors d’une variable implicite this, qui représente la nouvelle « instance ».</li>
					    <li>L’objet créé référence son constructeur : constructor.</li>
					</ul>
				</section>
				<section>
					<h2>Constructeur</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
}

var joeLopezPerson = new Person('Joe', 'Lopez');
var davidLopezz = new Person('David', 'lopez');
joeLopezPerson.first // => 'Joe'
davidLopezz.first   // => 'David'

// Si on jouait aux cons ?!
function LopezPerson(first, last) {
  this.first = first;
  this.last = last;
  return { first: 'Anne', last: 'Pas Lopez' };
}
var oops = new LopezPerson('Henry', 'Lopez');
oops.first // => Anne
						</code>
					</pre>
				</section>

				<section>
					<h2>Prototypes</h2>
					<ul>
					    <li>Tout constructeur a un prototype : un objet qui définit les propriétés (et donc méthodes) partagées par tous les objets que produit ce constructeur.</li>
					    <li>Le prototype est « vivant » : si on le triture après l’appel au constructeur, ça marche quand même !</li>
					    <li>Techniquement, y’a plein d’autres trucs dans un prototype (réf. au constructeur, gestion de propriétés…).</li>
						<li>On verra, plutôt vous verrez...</li>
					</ul>
				</section>
				<section>
					<h2>Constructeur</h2>
					<pre>
						<code class='javascript'>
function Person(first, last) {
  this.first = first;
  this.last = last;
}

// On augmente l'existant…
Person.prototype.fullName = function fullName() {
  return this.first + ' ' + this.last;
}
Person.prototype.greet = function greet() {
  alert('Salut je m’appelle ' + this.first);
}

var john = new Person('John', 'Smith');
john.fullName() // => 'John Smith'
john.greet()    // 'Salut je m’appelle John'
						</code>
					</pre>
				</section>

			</section>
			<section data-background='https://media.giphy.com/media/cxgLwcgy5qoXm/giphy.gif'>
				<h1>ES6 / 2015</h1>
			</section>
		</div>
	</div>
	<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>


</body>
</html>
